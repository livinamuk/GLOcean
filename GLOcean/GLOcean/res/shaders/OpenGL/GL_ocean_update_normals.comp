#version 430
layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba32f, binding = 0) uniform image2D NormalsImage;

struct Complex { 
    float r;
    float i;
};

struct VertexPN { 
    float x;
    float y;
    float z;
    float nx;
    float ny;
    float nz; 
};

layout(std430, binding = 1) readonly buffer BufferGradX  { Complex gradX[]; };
layout(std430, binding = 2) readonly buffer BufferGradZ  { Complex gradZ[]; };
layout(std430, binding = 3) buffer BufferMesh  { VertexPN mesh[]; };

uniform uvec2 u_oceanSize;
uniform uvec2 u_meshSize;

int Wrap(int v, int m) {
    int r = v % m;
    return r < 0 ? r + m : r;
}

void main() {
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (gid.x >= u_meshSize.x || gid.y >= u_meshSize.y) return;

    uint meshIdx = gid.y * u_meshSize.x + gid.x;

    ivec2 center = ivec2(u_oceanSize) / 2;
    ivec2 off = ivec2(gid) - center;

    int ox = Wrap(off.x, int(u_oceanSize.x));
    int oz = Wrap(off.y, int(u_oceanSize.y));
    uint oceanIdx = uint(oz) * u_oceanSize.x + uint(ox);

    float gx = gradX[oceanIdx].r;
    float gz = gradZ[oceanIdx].r;

    float sign = ((off.x + off.y) & 1) != 0 ? -1.0 : 1.0;
    vec3 n = normalize(vec3(sign * gx, 1.0, sign * gz));

    mesh[meshIdx].nx = n.x;
    mesh[meshIdx].ny = n.y;
    mesh[meshIdx].nz = n.z;
    
    if (gid.x < u_oceanSize.x || gid.y < u_oceanSize.y) {
	    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
        //imageStore(NormalsImage, pixelCoords, vec4(n.x, n.y, n.z, 0));
    }
}