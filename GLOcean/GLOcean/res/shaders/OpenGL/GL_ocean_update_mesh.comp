#version 450

struct Complex {
  float r;
  float i;
};

struct VertexPN {
  float x, y, z;
  float nx, ny, nz;
};

layout (std430, binding = 0) readonly restrict buffer BufferH {
  Complex h[];
};

layout (std430, binding = 1) readonly restrict buffer BufferDispX {
  Complex dispX[];
};

layout (std430, binding = 2) readonly restrict buffer BufferDispZ {
  Complex dispZ[];
};

layout (std430, binding = 3) writeonly restrict buffer BufferMesh {
  VertexPN mesh[];
};

layout(std430, binding = 4) readonly buffer BufferGradX  { Complex gradX[]; };
layout(std430, binding = 5) readonly buffer BufferGradZ  { Complex gradZ[]; };

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(r32f, binding = 0) uniform image2D heightImage;
layout(r32f, binding = 1) uniform image2D displacementXImage;
layout(r32f, binding = 2) uniform image2D displacementZImage;
layout(rgba32f, binding = 4) uniform image2D NormalsImage;

uniform uvec2 u_fftGridSize;
uniform uvec2 u_meshSize; 

int wrapIndex(int value, int modulus) {
    int r = value % modulus;
    return r < 0 ? r + modulus : r;
}

uniform float u_dispScale;
uniform float u_heightScale;

void main() {
    uvec2 meshUV = gl_GlobalInvocationID.xy;

    // Bail if out of bounds
    if (meshUV.x >= u_meshSize.x || meshUV.y >= u_meshSize.y) {
        return;
    }

    uint meshIndex = meshUV.y * u_meshSize.x + meshUV.x;

    ivec2 relativeUV = ivec2(meshUV) - ivec2(u_meshSize) / 2;

    uint wrappedU = uint((relativeUV.x % int(u_fftGridSize.x) + int(u_fftGridSize.x)) % int(u_fftGridSize.x));
    uint wrappedV = uint((relativeUV.y % int(u_fftGridSize.y) + int(u_fftGridSize.y)) % int(u_fftGridSize.y));
    uint fftIndex = wrappedV * u_fftGridSize.x + wrappedU;

    float checkerSign = ((relativeUV.x + relativeUV.y) & 1) != 0 ? 1.0 : -1.0;

    // Height
    float height = checkerSign * h[fftIndex].r * u_heightScale;

    // Displacement
    float dispX = -checkerSign * dispX[fftIndex].r * u_dispScale;
    float dispZ = -checkerSign * dispZ[fftIndex].r * u_dispScale;
   
    float x = float(relativeUV.x) + dispX;
    float z = float(relativeUV.y) + dispZ;

    // Compute normals
    ivec2 oceanCenter = ivec2(u_fftGridSize) / 2;
    ivec2 gradSampleUV = ivec2(meshUV) - oceanCenter;
    int wrappedGradU = wrapIndex(gradSampleUV.x, int(u_fftGridSize.x));
    int wrappedGradV = wrapIndex(gradSampleUV.y, int(u_fftGridSize.y));
    uint gradIndex = uint(wrappedGradV) * u_fftGridSize.x + uint(wrappedGradU);

    float gx = gradX[gradIndex].r;
    float gz = gradZ[gradIndex].r;
    float normalFlipSign = ((gradSampleUV.x + gradSampleUV.y) & 1) != 0 ? -1.0 : 1.0;
    vec3 normal = normalize(vec3(normalFlipSign * gx, 1.0, normalFlipSign * gz));

    mesh[meshIndex].x = x + (u_fftGridSize.x * 0.5);
    mesh[meshIndex].y = height;
    mesh[meshIndex].z = z + (u_fftGridSize.x * 0.5);

    if (meshUV.x < u_fftGridSize.x || meshUV.y < u_fftGridSize.y) {
        ivec2 outUV = ivec2(meshUV);
        imageStore(heightImage,        outUV, vec4(height, 0, 0, 0));
        imageStore(displacementXImage, outUV, vec4(dispX,  0, 0, 0));
        imageStore(displacementZImage, outUV, vec4(dispZ,  0, 0, 0));
        imageStore(NormalsImage,        outUV, vec4(normal, 0));
    }
}