#version 450

struct Complex {
    float r;
    float i;
};

struct VertexPN {
    float x, y, z;
    float nx, ny, nz;
};

layout (std430, binding = 0) readonly restrict buffer BufferH { Complex h[]; };
layout (std430, binding = 1) readonly restrict buffer BufferDispX { Complex dispX[]; };
layout (std430, binding = 2) readonly restrict buffer BufferDispZ { Complex dispZ[]; };
layout(std430, binding = 4) readonly buffer BufferGradX { Complex gradX[]; };
layout(std430, binding = 5) readonly buffer BufferGradZ { Complex gradZ[]; };

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(r32f, binding = 0) uniform image2D heightImage;
layout(r32f, binding = 1) uniform image2D displacementXImage;
layout(r32f, binding = 2) uniform image2D displacementZImage;
layout(rgba32f, binding = 4) uniform image2D NormalsImage;

uniform uvec2 u_fftGridSize;

uniform float u_dispScale;
uniform float u_heightScale;

void main() {
    uvec2 pixelcoords = gl_GlobalInvocationID.xy;

     if (pixelcoords.x >= u_fftGridSize.x || pixelcoords.y >= u_fftGridSize.y)
        return;

    uint fftIndex = pixelcoords.y * u_fftGridSize.x + pixelcoords.x;

    float checkerSign = ((pixelcoords.x + pixelcoords.y) & 1) != 0 ? 1.0 : -1.0;

    // Height
    float height = checkerSign * h[fftIndex].r * u_heightScale;

    // Displacement
    float dispX = -checkerSign * dispX[fftIndex].r * u_dispScale;
    float dispZ = -checkerSign * dispZ[fftIndex].r * u_dispScale;
   
    float x = float(pixelcoords.x) + dispX;
    float z = float(pixelcoords.y) + dispZ;

    float gx = gradX[fftIndex].r;
    float gz = gradZ[fftIndex].r;
    float normalFlipSign = ((pixelcoords.x + pixelcoords.y) & 1) != 0 ? -1.0 : 1.0;
    vec3 normal = normalize(vec3(normalFlipSign * gx, 1.0, normalFlipSign * gz));

    ivec2 outUV = ivec2(pixelcoords);
    imageStore(heightImage, outUV, vec4(height, 0, 0, 0));
    imageStore(displacementXImage, outUV, vec4(dispX, 0, 0, 0));
    imageStore(displacementZImage, outUV, vec4(dispZ, 0, 0, 0));
    imageStore(NormalsImage, outUV, vec4(normal, 0));
}