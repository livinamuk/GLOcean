#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba8, binding = 0) uniform image2D outputImage;

layout(binding = 0) uniform sampler2D WorldPositionTexture;
layout(binding = 1) uniform sampler2D DisplacementTexture;

uniform uvec2 u_fftGridSize;
uniform float u_oceanModelMatrixScale;
uniform float u_oceanOriginY;

void main() {
	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);   
    ivec2 outputImageSize = imageSize(outputImage);
    vec2 uv_screenspace = vec2(pixelCoords) / vec2(outputImageSize);

    // Don't process out of bounds pixels
    if (pixelCoords.x >= outputImageSize.x || pixelCoords.y >= outputImageSize.y) {
        return;
    }    
    
    vec4 lighting = imageLoad(outputImage, pixelCoords);
    vec3 worldPosition = texture(WorldPositionTexture, uv_screenspace).rgb;

    // Skip skybox
    if (worldPosition == vec3(0,0,0)) {
        return;
    }

    const float gridCellsPerWorldUnit = 1.0 / u_oceanModelMatrixScale;
    const vec2 fftGridSize = vec2(u_fftGridSize);
    const vec2 patchWorldSize = fftGridSize * u_oceanModelMatrixScale;
    
    vec2 bestGuessUV = fract(worldPosition.xz / patchWorldSize);
    
    float dispX = texture(DisplacementTexture, bestGuessUV).x;
    float dispZ = texture(DisplacementTexture, bestGuessUV).z;

    vec2 estimatedDisplacement = vec2(dispX, dispZ) / gridCellsPerWorldUnit;
    vec2 estimatedWorldPosition = worldPosition.xz - estimatedDisplacement;
    vec2 estimatedUV = fract(estimatedWorldPosition / patchWorldSize);
    
    float height = texture(DisplacementTexture, estimatedUV).y;
    
    float waterHeight = (height * u_oceanModelMatrixScale) + u_oceanOriginY;
    bool isUnderwater = worldPosition.y < waterHeight;
    
    vec3 seaColor = vec3(0.286, 0.612, 0.576) * 0.05;
    
    if (isUnderwater) {
        vec3 finalColor = mix(lighting.rgb * seaColor, lighting.rgb, 0.75);
        finalColor = vec3(1 ,0, 0);
        //finalColor = lighting.rgb * seaColor;
        imageStore(outputImage, pixelCoords, vec4(finalColor, 1));
    }



    // Foam line
    //float d = abs(worldPosition.y - waterHeight + 0.001);
    //float edge = smoothstep(0.05, 0.0, d);
    //seaColor = lighting.rgb + vec3(0.1);
    //lighting.rgb = mix(lighting.rgb, seaColor, edge);
    //imageStore(outputImage, pixelCoords, vec4(lighting.rgb, 1));
}