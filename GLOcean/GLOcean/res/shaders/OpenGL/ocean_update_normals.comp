#version 430
layout(local_size_x = 16, local_size_y = 16) in;

struct Complex { float r,i; };
struct VertexPN { float x,y,z,nx,ny,nz; };

layout(std430, binding = 0) readonly  buffer BufferH     { Complex    h[];      };
layout(std430, binding = 1) readonly  buffer BufferGradX { Complex    gradX[]; };
layout(std430, binding = 2) readonly  buffer BufferGradZ { Complex    gradZ[]; };
layout(std430, binding = 3) writeonly buffer BufferMesh  { VertexPN   mesh[];   };

uniform uvec2 oceanSize; // e.g. (256,256)
uniform uvec2 meshSize;  // e.g. (257,257)

int wrap(int v, int m) {
    int r = v % m;
    return r < 0 ? r + m : r;
}

void main() {
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (gid.x >= meshSize.x || gid.y >= meshSize.y) return;

    uint meshIdx = gid.y * meshSize.x + gid.x;

    // center the grid around (0,0)
    ivec2 center = ivec2(meshSize) / 2;
    ivec2 off    = ivec2(gid) - center;

    // wrap into [0..oceanSize)
    int ox = wrap(off.x, int(oceanSize.x));
    int oz = wrap(off.y, int(oceanSize.y));
    uint oceanIdx = uint(oz) * oceanSize.x + uint(ox);

    // checkerboard for inverse FFT
    float sign = ((off.x + off.y) & 1) != 0 ? -1.0 : 1.0;

    // sample your precomputed gradients
    float gx = gradX[oceanIdx].r;
    float gz = gradZ[oceanIdx].r;

    // assemble and normalize
    vec3 n = normalize(vec3(sign * gx, 1.0, sign * gz));
    
    mesh[meshIdx].nx = n.x;
    mesh[meshIdx].ny = n.y;
    mesh[meshIdx].nz = n.z;

}
